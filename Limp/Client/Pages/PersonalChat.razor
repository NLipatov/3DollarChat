@page "/user/{topicName?}"
@using ClientServerCommon.Models;
@using ClientServerCommon.Models.Message;
@using Limp.Client.Cryptography.CryptoHandlers.Handlers;
@using Limp.Client.Cryptography.KeyStorage;
@using Limp.Client.HubInteraction.Handlers;
@using Limp.Client.HubInteraction;
@using Limp.Client.HubInteraction.Handlers.Helpers;
@using Limp.Client.Services.HubServices.MessageService;
@using Limp.Client.Services;
@using Microsoft.AspNetCore.SignalR.Client;
@using Limp.Client.Cryptography;
@using Limp.Client.HubInteraction.Handlers.MessageDecryption;
@using Limp.Client.HubInteraction.Handlers.MessageDispatcherHub.AESOfferHandling;
@using Limp.Client.TopicStorage;
@using LimpShared.Encryption;
@using Limp.Client.Pages;
@inject NavigationManager Navigation
@inject IJSRuntime jS
@inject ICryptographyService _cryptographyService
@inject IMessageDecryptor _messageDecryptor
@inject IMessageBox _messageBox
@inject IAESOfferHandler _aesOfferHandler
@inject IMessageService _messageService
@implements IAsyncDisposable

<PageTitle>Chat with @topicName</PageTitle>

<div class="page-container">
    @if (!isAcceptedAESKeyExists)
    {
        <KeyTransfer 
            IsThereAnAESKey=isAcceptedAESKeyExists/>
    }
    else
    {
        <div class="header">
            <span>@topicName</span>
        </div>

        <div class="messages-box">
            @foreach (var message in messages.Where(x=>x.Type == MessageType.UserMessage))
            {
                bool isOutcoming = message.Sender == "You";
                string messageClass = isOutcoming ? "outcoming" : "incoming";
                <div class="message @messageClass">
                    <span>@(message.Payload)</span>
                </div>
                <div class="timestamp @messageClass">
                    <span>@message.DateSent.ToString("hh:mm")</span>
                    @if (message.IsReceived)
                    {
                        <span>R</span>
                    }
                </div>

            }
        </div>

        <div class="message-input-box">
            <input @bind="messageInput" />
            <button @onclick="async () => await SendMessage()" disabled="@isSendButtonDisabled">Send</button>
        </div>
    }
</div>

@code {
    [Parameter]
    public string topicName { get; set; } = string.Empty;
    [Parameter]
    public string? myName { get; set; }
    private HubConnection? messageDispatcherHub;
    public bool IsConnectedToMessageDispatcherHub => messageDispatcherHub?.State == HubConnectionState.Connected;
    private List<Message> messages { get; set; } = new();
    private string messageInput = string.Empty;
    private List<UserConnection> userConnections { get; set; } = new();
    private bool isAcceptedAESKeyExists { get; set; } = false;
    private bool isSendButtonDisabled { get; set; } = false;
    private Guid? MessageService_SubscriptionToPartnerAESAccept { get; set; }
    private Guid? MessageBox_OnMessageReceived { get; set; }
    private Guid? MessageService_SubscrriptionToMessageReceivedByRecepient { get; set; }

    protected override async Task OnInitializedAsync()
    {
        await ResolveMyUsername();

        MessageService_SubscriptionToPartnerAESAccept = _messageService.SubscribeToPartnerAESAccept(OnAESKeyReadyAsync);
        MessageService_SubscrriptionToMessageReceivedByRecepient = _messageService.SubscribeToMessageReceivedByRecepient(MyMessageWasReceived);
        MessageBox_OnMessageReceived = _messageBox.Subsctibe(TheirMessageWasReceived);

        LoadPreviousMessagesForThisTopic();
        await GetAnAESKeyForConversation();
    }

    private async Task ResolveMyUsername()
    {
        string? accessToken = await JWTHelper.GetAccessToken(jS);
        if (string.IsNullOrWhiteSpace(accessToken))
        {
            Navigation.NavigateTo("/login");
            return;
        }
        myName = TokenReader.GetUsername(accessToken);
    }

    private async Task GetAnAESKeyForConversation()
    {
        if (InMemoryKeyStorage.AESKeyStorage.FirstOrDefault(x => x.Key == topicName).Value == null)
        {
            Console.WriteLine($"There is no existing AES key for conversation. Let's create one");
            //This will get partners public key and generate an AES key for conversation
            await _messageService.RequestForPartnerPublicKey(topicName);
        }
        else
        {
            Console.WriteLine($"There is an existing AES key for conversation: {InMemoryKeyStorage.AESKeyStorage.FirstOrDefault(x => x.Key == topicName).Value.Value.ToString()}");
            isAcceptedAESKeyExists = true;
            StateHasChanged();
        }
    }

    private async Task OnAESKeyReadyAsync(string partnerName)
    {
        InMemoryKeyStorage.AESKeyStorage.First(x => x.Key == partnerName).Value.IsAccepted = true;
        string? keyForConversation = InMemoryKeyStorage.AESKeyStorage.FirstOrDefault(x => x.Key == partnerName).Value?.Value?.ToString();
        isAcceptedAESKeyExists = !string.IsNullOrWhiteSpace(keyForConversation);
        StateHasChanged();
    }

    private void LoadPreviousMessagesForThisTopic()
    {
        if (string.IsNullOrWhiteSpace(topicName))
        {
            throw new ApplicationException("Chat topic name was not resolved, could not messages from this topic.");
        }

        var messagesFromMessageBox = _messageBox.FetchMessagesFromMessageBox(topicName);
        messages.AddRange(messagesFromMessageBox);
    }

    private async Task OnUsernameResolve(string username)
    {
        myName = username;
        await GetAnAESKeyForConversation();
        StateHasChanged();
    }

    private void TheirMessageWasReceived(Message message)
    {
        if (message.Sender == "You")
            return;

        if(message.Type == MessageType.UserMessage)
        {
            messages.Add(message);
            StateHasChanged();
        }
    }

    private void MyMessageWasReceived(Guid messageId)
    {
        Message? receivedMessage = messages.FirstOrDefault(x => x.Id == messageId);
        if (receivedMessage != null)
        {
            receivedMessage.IsReceived = true;
            StateHasChanged();
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(messageInput))
            return;

        Cryptogramm cryptogramm = await _cryptographyService
        .EncryptAsync<AESHandler>(new Cryptogramm() { Cyphertext = messageInput }, contact: topicName);

        Message messageToSend = new Message
        {
            Topic = topicName,
            Cryptogramm = cryptogramm,
            DateSent = DateTime.UtcNow,
            TargetGroup = topicName!,
            Sender = myName ?? throw new ApplicationException("Message was not send"),
        };

        await _messageService.SendMessage(messageToSend);

        messageToSend.Payload = messageInput;
        messageToSend.Sender = "You";
        messages.Add(messageToSend);
        await _messageBox.AddMessageAsync(messageToSend, isEncrypted: false);

        messageInput = string.Empty;
    }

    public async ValueTask DisposeAsync()
    {
        if (MessageService_SubscriptionToPartnerAESAccept.HasValue)
        {
            _messageService.RemoveSubscriptionToPartnerAESAccept(MessageService_SubscriptionToPartnerAESAccept.Value);
        }
        if(MessageService_SubscrriptionToMessageReceivedByRecepient.HasValue)
        {
            _messageService.RemoveSubscriptionToMessageReceivedByRecepient(MessageService_SubscrriptionToMessageReceivedByRecepient.Value);
        }
        if (MessageBox_OnMessageReceived.HasValue)
        {
            _messageBox.Unsubscribe(MessageBox_OnMessageReceived.Value);
        }
    }
}
