@page "/user/{topicName?}"
@using Limp.Client.HubConnectionManagement.ConnectionHandlers.MessageDispatcher.AESOfferHandling;
@using Limp.Client.Pages.PersonalChat.UI.Childs.MessageInput
@using ClientServerCommon.Models;
@using ClientServerCommon.Models.Message;
@using Limp.Client.Cryptography.CryptoHandlers.Handlers;
@using Limp.Client.Cryptography.KeyStorage;
@using Limp.Client.HubInteraction.Handlers;
@using Limp.Client.HubInteraction;
@using Limp.Client.HubInteraction.Handlers.Helpers;
@using Limp.Client.Pages.PersonalChat.Logic.TokenRelatedOperations;
@using Limp.Client.Pages.PersonalChat.UI.Childs.ChatHeader
@using Limp.Client.Services.CloudKeyService;
@using Limp.Client.Services.CloudKeyService.Models;
@using Limp.Client.Services.HubService.UsersService;
@using Limp.Client.Services.HubServices.CommonServices.SubscriptionService;
@using Limp.Client.Services.HubServices.MessageService;
@using Limp.Client.Services;
@using Limp.Client.Services.UndeliveredMessagesStore;
@using Microsoft.AspNetCore.SignalR.Client;
@using Limp.Client.Cryptography;
@using Limp.Client.HubInteraction.Handlers.MessageDecryption;
@using LimpShared.Encryption;
@using Limp.Client.Pages;
@using Limp.Client.Services.InboxService;
@using Limp.Client.Pages.PersonalChat.Logic.MessageBuilder;
@using Limp.Client.Pages.PersonalChat.UI.Childs.MessageCollectionDispaying;
@using Limp.Client.Pages.AuthenticationChecks
@inject NavigationManager _navigationManager
@inject IJSRuntime _jS
@inject ICryptographyService _cryptographyService
@inject IMessageDecryptor _messageDecryptor
@inject IMessageBox _messageBox
@inject IAESOfferHandler _aesOfferHandler
@inject IMessageService _messageService
@inject IHubServiceSubscriptionManager _hubServiceSubscriptionManager
@inject IMessageBuilder _messageBuilder
@inject ILocalKeyManager _localKeyManager
@inject IUsersService _usersService
@inject IUndeliveredMessagesRepository _undeliveredMessagesRepository
@implements IDisposable

<PageTitle>Chat with @topicName</PageTitle>

<AuthenticatedView>
    <AuthenticatedContent>

            <KeyBeingTransfered IsDisplayed=@(AESKey == null) />

            <ChatHeader 
                IsOnline=true
                PartnerName=@topicName
                OnAESRenewal=@RenewAES 
                AESKey=@AESKey/>

            <MessageList @ref=MessageListComponent
                        topicName=@topicName />

            <MessageInputBox 
                myUsername=@myUsername
                topicName=@topicName/>

    </AuthenticatedContent>
    <UnauthenticatedContent>
        <UnAuthorized/>
    </UnauthenticatedContent>
</AuthenticatedView>

@code {
    [Parameter]
    public string topicName { get; set; } = string.Empty;
    [Parameter]
    public string myUsername { get; set; } = string.Empty;
    private List<UserConnection> userConnections { get; set; } = new();
    private bool AESKeyForConversationExists => GetAESKey() != null;
    private Key? AESKey { get; set; }
    private Guid ComponentId { get; set; }
    private MessageList? MessageListComponent { get; set; } = new();

    public void Dispose() => _hubServiceSubscriptionManager.RemoveComponentCallbacks(ComponentId);

    protected override async Task OnInitializedAsync()
    {
        //This id will be needed on dispose stage
        //On dispose stage we need to clear out all of the component event subscriptions
        ComponentId = Guid.NewGuid();

        myUsername = await TokenOperations.ResolveMyUsername(_jS);

        //If username was not read, ask user to relogin
        if (string.IsNullOrWhiteSpace(myUsername))
        {
            _navigationManager.NavigateTo("/login");
            return;
        }

        SubscribeToHubEvents();

        await GetAESKeyAsync();

        await _usersService.CheckIfUserOnline(topicName);
    }

    private void SubscribeToHubEvents()
    {
        _hubServiceSubscriptionManager.AddCallback<string>(OnAESKeyReady, "OnPartnerAESKeyReady", ComponentId);
        _hubServiceSubscriptionManager.AddCallback<bool>(OnAESUpdated, "AESUpdated", ComponentId);
        _hubServiceSubscriptionManager.AddCallback<UserConnection>(UserIsOnline, "IsUserOnlineResponse", ComponentId);
    }

    private void OnAESUpdated(bool keyRenewed)
    {
        AESKey = InMemoryKeyStorage.AESKeyStorage.FirstOrDefault(x => x.Key == topicName).Value;
        StateHasChanged();
    }

    private async Task UserIsOnline(UserConnection userConnection)
    {
        List<Message> undelivered = await _undeliveredMessagesRepository.GetUndeliveredAsync();

        if (undelivered.Count == 0)
            return;

        List<Message> messages = new List<Message>(undelivered.Count);
        Task[] buildWorkload = BuildMessages(undelivered, messages);
        await Task.WhenAll(buildWorkload);

        Task[] sendWorkload = SendMessages(messages);

        await Task.WhenAll(sendWorkload);
    }

    private Task[] BuildMessages(List<Message> plainTextMessages, List<Message> messagesToBeSend)
    {
        Task[] workload = new Task[plainTextMessages.Count];
        for (int i = 0; i < plainTextMessages.Count; i++)
        {
            workload[i] = Task.Run(async () =>
            {
                messagesToBeSend.Add(await _messageBuilder.BuildMessageToBeSend(plainTextMessages[i].Payload, topicName, myUsername));
            });
        }

        return workload;
    }

    private Task[] SendMessages(List<Message> messagesToSend)
    {
        Task[] workload = new Task[messagesToSend.Count];
        for (int i = 0; i < messagesToSend.Count; i++)
        {
            workload[i] = Task.Run(async () =>
            {
                await _messageService.SendMessage(messagesToSend[i]);
            });
        }

        return workload;
    }

    private async Task GetAESKeyAsync()
    {
        AESKey = await GetAESKey();
        if (AESKey != null)
        {
            return;
        }

        await RenewAES();
    }

    private async Task RenewAES()
    {
        await _messageService.RequestForPartnerPublicKey(topicName);
    }

    private async Task<Key?> GetAESKey()
    {
        LocalKeyChain? localKeyChain = (await _localKeyManager.ReadLocalKeyChainAsync());
        Key? key = localKeyChain?.AESKeyStorage.FirstOrDefault(x => x.Key == topicName).Value;

        Key? keyFromInMemoryService = InMemoryKeyStorage.AESKeyStorage.FirstOrDefault(x => x.Key == topicName).Value;

        if (keyFromInMemoryService == null && key != null)
        {
            InMemoryKeyStorage.AESKeyStorage.Add(topicName, key);
            keyFromInMemoryService = InMemoryKeyStorage.AESKeyStorage.FirstOrDefault(x => x.Key == topicName).Value;
        }

        if(keyFromInMemoryService != null)
        {
            Console.WriteLine($"Using key created at: {keyFromInMemoryService.CreationDate.ToLocalTime().ToString("dd/MM HH:mm")}");
        }
        else
        {
            Console.WriteLine("No key found");
        }

        return keyFromInMemoryService;
    }

    public async Task OnAESKeyReady(string partnerName)
    {
        AESKey = await GetAESKey();
        if (AESKey == null)
            throw new ApplicationException("Could not get an AES key.");

        await _localKeyManager.SynchronizeWithInMemoryKeyStorageAsync();
        StateHasChanged();
    }
}
