@inject IJSRuntime JsRuntime

<div @ref="_scrollContainer" @onscroll="OnScroll" style="overflow-y: scroll; width: 100%;">
    <div style="height:@TopSpacerHeight"></div>

    @foreach (var component in _visibleComponents)
    {
        <div id="component-@(component.Id)">
            @component.Content
        </div>
    }

    <div style="height:@BottomSpacerHeight"></div>
</div>

@code {
    [Parameter] public List<RenderFragment>? Components { get; set; }

    private ElementReference _scrollContainer;
    private List<ScrollComponent> _visibleComponents = new();

    private Dictionary<int, double> _componentHeights = new();
    private double _topSpacerHeight = 0;
    private double _bottomSpacerHeight = 0;
    private const int VisibleComponentCount = 15;
    private int _startIndex = 0;
    private int EndIndex => _startIndex + VisibleComponentCount - 1;
    private bool _autoScroll = true;

    protected override Task OnParametersSetAsync()
    {
        UpdateVisibleComponents();
        return base.OnParametersSetAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            if (Components != null && Components.Any())
            {
                UpdateVisibleComponents();
            }

            await ScrollToBottom();
        }

        await MeasureUncachedHeights();
        UpdateSpacers();
    }

    private async Task OnScroll()
    {
        var scrollPosition = await JsRuntime.InvokeAsync<double>("virtualScrolling.getScrollPosition", _scrollContainer);

        _autoScroll = await IsScrolledToBottom();

        if (scrollPosition == 0)
        {
            await LoadUpperComponents(); 
        }
        else if (_autoScroll)
        {
            await LoadLowerComponents();
        }

        await RemoveOutOfViewComponents();
    }

    private async Task ScrollToBottom()
    {
        await JsRuntime.InvokeVoidAsync("virtualScrolling.scrollToBottom", _scrollContainer);
    }

    private async Task<bool> IsScrolledToBottom()
    {
        return await JsRuntime.InvokeAsync<bool>("virtualScrolling.isScrolledToBottom", _scrollContainer);
    }

    private async Task RemoveOutOfViewComponents()
    {
        if (Components == null || !Components.Any())
            return;

        while (_startIndex < Components.Count && await ComponentOutOfView(_visibleComponents.First()))
        {
            await CacheComponentHeight(_visibleComponents.First());
            _visibleComponents.RemoveAt(0);
            _startIndex++;
        }

        while (EndIndex < Components.Count && await ComponentOutOfView(_visibleComponents.Last()))
        {
            await CacheComponentHeight(_visibleComponents.Last());
            _visibleComponents.RemoveAt(_visibleComponents.Count - 1);
        }

        UpdateSpacers();
        StateHasChanged();
    }

    private async Task<bool> ComponentOutOfView(ScrollComponent component)
    {
        double componentPosition = await JsRuntime.InvokeAsync<double>("virtualScrolling.getElementPosition", $"component-{component.Id}");
        double containerHeight = await GetContainerHeight();
        return componentPosition < 0 || componentPosition > containerHeight;
    }

    private async Task CacheComponentHeight(ScrollComponent component)
    {
        if (!_componentHeights.ContainsKey(component.Id))
        {
            var height = await JsRuntime.InvokeAsync<double>("virtualScrolling.getElementHeight", $"component-{component.Id}");
            _componentHeights[component.Id] = height;
        }
    }

    private async Task MeasureUncachedHeights()
    {
        foreach (var component in _visibleComponents)
        {
            await CacheComponentHeight(component);
        }
    }

    private void UpdateVisibleComponents()
    {
        if (Components == null || !Components.Any())
            return;

        _visibleComponents = Components.Skip(_startIndex).Take(VisibleComponentCount)
            .Select((component, index) => new ScrollComponent
            {
                Id = _startIndex + index,
                Content = component
            }).ToList();
        
        UpdateSpacers();
    }

    private void UpdateSpacers()
    {
        if (Components == null || !Components.Any())
            return;

        _topSpacerHeight = CalculateSpacerHeight(0, _startIndex);
        _bottomSpacerHeight = CalculateSpacerHeight(EndIndex + 1, Components.Count);
    }

    private double CalculateSpacerHeight(int start, int end)
    {
        double height = 0;
        for (int i = start; i < end; i++)
        {
            if (_componentHeights.ContainsKey(i))
            {
                height += _componentHeights[i];
            }
            else
            {
                height += 50;
            }
        }
        return height;
    }

    private async Task<double> GetContainerHeight()
    {
        return await JsRuntime.InvokeAsync<double>("virtualScrolling.getContainerHeight", _scrollContainer);
    }

    private async Task LoadUpperComponents()
    {
        if (_startIndex > 0)
        {
            _startIndex = Math.Max(0, _startIndex - VisibleComponentCount);
            UpdateVisibleComponents();
        }
    }

    private async Task LoadLowerComponents()
    {
        if (EndIndex < Components.Count - 1)
        {
            _startIndex = Math.Min(Components.Count - VisibleComponentCount, _startIndex + VisibleComponentCount);
            UpdateVisibleComponents();
        }
    }

    private double TopSpacerHeight => _topSpacerHeight;
    private double BottomSpacerHeight => _bottomSpacerHeight;

    public async Task AddComponent(RenderFragment newComponent)
    {
        if (Components == null)
        {
            Components = new List<RenderFragment>();
        }

        Components.Add(newComponent);

        if (_autoScroll)
        {
            await ScrollToBottom();
        }

        StateHasChanged();
    }

    public class ScrollComponent
    {
        public int Id { get; set; }
        public RenderFragment Content { get; set; }
        public int? Height { get; set; }
    }
}
