@using EthachatShared.Models.Message
@using System.Text
@using Ethachat.Client.Services.VideoStreamingService.Converters.FFmpeg.HlsEncryption
@using Ethachat.Client.Services.AuthenticationService.Handlers
@inject IJSRuntime JsRuntime
@namespace Ethachat.Client.UI.Chat.UI.Childs.MessageCollectionDispaying.Childs.SingleMessagesByType
@implements IAsyncDisposable

<video id=@Message.Id width="300" height="200" autoplay controls></video>

@code {
    [Parameter] public required Message Message { get; set; }
    private List<string> _tempBlobUrls = new();

    protected override void OnAfterRender(bool firstRender)
    {
        base.OnAfterRender(firstRender);

        Task.Run(async () => await PrepareHlsStreamingVideo());
    }

    private async Task PrepareHlsStreamingVideo()
    {
        if (string.IsNullOrWhiteSpace(Message.HlsPlaylist?.M3U8Content))
            throw new ArgumentException($"Invalid {nameof(Message.HlsPlaylist.M3U8Content)} value");

        var keyFileGenerator = new HlsEncryptionManager(JsRuntime, Message!.Id.ToString());
        //Generate a key file
        var keyFile = keyFileGenerator.GenerateKeyFile(Message.HlsPlaylist!.HexKey);
        //Create a blob with key file
        var keyFileUri = await ToBlobUrlAsync(keyFile, "application/octet-stream");

        var sb = new StringBuilder();
        foreach (var line in Message.HlsPlaylist.M3U8Content.Split("\n"))
        {
            var modifiedLine = line;
            if (line.StartsWith("#EXT-X-KEY:METHOD=AES-128"))
            {
                modifiedLine = $"#EXT-X-KEY:METHOD=AES-128,URI=\"{keyFileUri}\",IV=0x{Message.HlsPlaylist.HexIv}";
            }

            sb.AppendLine(modifiedLine);
        }

        var playlistContent = sb.ToString();

        var playlistBytes = Encoding.UTF8.GetBytes(playlistContent);
        var playlistUrl = await ToBlobUrlAsync(playlistBytes, "application/vnd.apple.mpegurl");

        await JsRuntime.InvokeVoidAsync("startStream", playlistUrl, Message.Id);
    }

    private async Task<string> ToBlobUrlAsync(byte[] bytes, string mimeType)
    {
        var fileUri = await JsRuntime.InvokeAsync<string>("createBlobUrl", bytes, mimeType);
        _tempBlobUrls.Add(fileUri);
        return fileUri;
    }

    public async ValueTask DisposeAsync()
    {
        foreach (var tempBlobUrl in _tempBlobUrls.Where(x => !string.IsNullOrWhiteSpace(x)))
            await JsRuntime.InvokeVoidAsync("revokeBlobUrl", tempBlobUrl);
    }

}