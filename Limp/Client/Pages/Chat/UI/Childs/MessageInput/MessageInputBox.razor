@using Limp.Client.ClientOnlyModels.ClientOnlyExtentions
@using Limp.Client.Pages.Chat.Logic.MessageBuilder;
@using Limp.Client.Services.HubServices.HubServices.Implementations.MessageService
@using Limp.Client.Services.InboxService;
@using System.Text
@using Limp.Client.ClientOnlyModels
@using Limp.Client.Cryptography.CryptoHandlers
@using Limp.Client.Cryptography.KeyStorage
@using Limp.Client.HubInteraction.Handlers.MessageDecryption
@using Limp.Client.Services.DataTransmission.PackageForming
@using Limp.Client.Services.HubServices.CommonServices.CallbackExecutor
@using LimpShared.Encryption
@using LimpShared.Models.Message.DataTransfer
@inject IMessageBuilder _messageBuilder
@inject IMessageService _messageService
@inject IMessageBox _messageBox
@inject IJSRuntime _jSRuntime
@inject IMessageDecryptor _messageDecryptor 
@inject IPackageMultiplexerService PackageMultiplexerService
@inject ICallbackExecutor CallbackExecutor

<div class="message-input-box" @onkeydown="((e) => OnKeyDown(e))">
    <input @bind="MessageInput" @bind:event="oninput"/>

    <label for="fileinput" class="label-wrapper" style="align-items: center;">
        <span class="bi bi-paperclip"></span>
        <InputFile id="fileinput" @key="FileInputId" OnChange="OnFileInput" style="display: none; font-size: 0.7rem;"/>
        @if (DataFiles.Any())
        {
            @foreach (var file in DataFiles)
            {
                <span title=@file.Packages.First().FileName style="    
                        overflow: hidden;
                        max-width: 10vw;
                        white-space: nowrap;
                        text-overflow: ellipsis;">
                    @file.Packages.First().FileName
                </span>
            }
        }
    </label>

    <button disabled="@(!_messageService.IsConnected())" @onclick="async () => await SendMessage()">Send</button>
</div>

<Modal @ref="MaxFileSizeRestrictionModal" Title="Modal title">
    <BodyTemplate>
        Maximum file size is limited to @Math.Floor((decimal)(MaxFileSizeBytes / 1024000)) MB.
    </BodyTemplate>
    <FooterTemplate>
        <Button Color="ButtonColor.Secondary" @onclick="(async () => await MaxFileSizeRestrictionModal.HideAsync())">Close</Button>
    </FooterTemplate>
</Modal>

<FileEncryptionModal/>

@code {

    [Parameter]
    public string TopicName { get; set; } = string.Empty;

    [Parameter]
    public string MyUsername { get; set; } = string.Empty;

    private string MessageInput { get; set; } = string.Empty;
    private List<ClientDataFile> DataFiles { get; set; } = new();
    public Guid FileInputId = Guid.NewGuid();
    private Modal MaxFileSizeRestrictionModal = default!;
        private const int MaxFileSizeBytes = 5242880;

    private async Task OnKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
            await SendMessage();
    }

    private async Task OnFileInput(InputFileChangeEventArgs e)
    {
        if (e.File.Size > MaxFileSizeBytes)
        {
            await MaxFileSizeRestrictionModal.ShowAsync();
            FileInputId = Guid.NewGuid();
            return;
        }

        try
        {
            CallbackExecutor.ExecuteSubscriptionsByName(true, "OnIsFileBeingEncrypted");
            await Split(e.File, 20 * 1024 /*KiB*/, TopicName);
        }
        finally
        {
            CallbackExecutor.ExecuteSubscriptionsByName(false, "OnIsFileBeingEncrypted");
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(MessageInput) && !DataFiles.Any() || string.IsNullOrWhiteSpace(TopicName) || string.IsNullOrWhiteSpace(MyUsername))
        {
            MessageInput = string.Empty;
            return;
        }

        if (!string.IsNullOrWhiteSpace(MessageInput))
        {
            await _messageService.SendText(MessageInput, TopicName, MyUsername);
        }

        if (DataFiles.Any())
        {
            var dataFilesCopy = new List<ClientDataFile>(DataFiles);
            Task.Run(() => _messageService.SendData(dataFilesCopy, TopicName));
            FileInputId = Guid.NewGuid();
        }

        MessageInput = string.Empty;
        DataFiles = new(0);
    }

    public async Task Split(IBrowserFile file, int maxPackageSizeBytes, string partnerUsername)
    {
        var aesKey = InMemoryKeyStorage.AESKeyStorage
            .First(x => x.Key == partnerUsername).Value.Value?.ToString();
        if (string.IsNullOrWhiteSpace(aesKey))
            throw new ArgumentException($"Exception:{nameof(MessageInputBox)}.{nameof(Split)}:" +
                                        $"No AES key stored for {partnerUsername}.");
        
        var fileDataId = Guid.NewGuid();
        var bytes = await FileToBytes(file);
        var b64Decrypted = Convert.ToBase64String(bytes);
        var b64DecryptedChunks = SplitString(b64Decrypted, maxPackageSizeBytes);

        List<string> ivs = new List<string>(b64DecryptedChunks.Count);
        List<string> b64Encrypted = new List<string>(b64DecryptedChunks.Count);

        for (int i = 0; i < b64DecryptedChunks.Count; i++)
        {
            var encrypted = await _jSRuntime.InvokeAsync<string>("AESEncryptText", b64DecryptedChunks[i], aesKey);
            b64Encrypted.Add(encrypted);

            var iv = await _jSRuntime.InvokeAsync<string>("ExportIV");
            ivs.Add(iv);

            decimal progress = Math.Round(i / (decimal)b64DecryptedChunks.Count * 100);
            CallbackExecutor.ExecuteSubscriptionsByName(progress, "OnFileEncryptionProgressChanged");
        }
        
        var decryptedChunks = new string[b64Encrypted.Count];

        for (int i = 0; i < b64Encrypted.Count; i++)
        {            
            await _jSRuntime.InvokeAsync<string>("ImportIV", ivs[i]);
            decryptedChunks[i] = await _jSRuntime.InvokeAsync<string>("AESDecryptText", b64Encrypted[i], aesKey);
        }

        List<ClientPackage> packages = new List<ClientPackage>(b64DecryptedChunks.Count);

        for (int i = 0; i < b64Encrypted.Count; i++)
        {
            packages.Add(new ClientPackage
            {
                FileDataid = fileDataId,
                FileName = file.Name,
                ContentType = file.ContentType,
                Index = i,
                Total = b64Encrypted.Count,
                B64Data = b64Encrypted[i],
                IV = ivs[i],
                PlainB64Data = decryptedChunks[i]
            });
        }
        
        DataFiles.Add(new ClientDataFile()
        {
            Id = fileDataId,
            ClientPackages = packages,
            Packages = packages
                .Select(x => x.ToPackage())
                .ToList(),
        });
        
        StateHasChanged();
    }

    private List<string> SplitString(string input, int maxLength)
    {
        List<string> result = new List<string>();

        for (int i = 0; i < input.Length; i += maxLength)
        {
            int length = Math.Min(maxLength, input.Length - i);
            result.Add(input.Substring(i, length));
        }

        return result;
    }

    private async Task<byte[]> FileToBytes(IBrowserFile file)
    {
        using (var s = file.OpenReadStream(MaxFileSizeBytes))
        {
            using (var ms = new MemoryStream())
            {
                await s.CopyToAsync(ms);
                return ms.ToArray();
            }
        }
    }
}