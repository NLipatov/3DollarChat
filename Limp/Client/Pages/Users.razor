@page "/users"
@using Limp.Client.HubInteraction;
@using Limp.Shared.Models.Login;
@using Limp.Client.Utilities;
@using LimpShared.Authentification;
@using Microsoft.AspNetCore.SignalR.Client;
@inject NavigationManager Navigation
@using Limp.Shared.Models;
@inject IJSRuntime jS
@implements IAsyncDisposable

<PageTitle>Users Online</PageTitle>

<div style="display: flex; flex-direction: column; gap: 10px;">
    @foreach (var connection in userConnections.Where(x=>!x.ConnectionIds.Contains(myConnectionId) && x.ConnectionIds.Count > 0))
    {
        <div style="    
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border: 1px solid;">
            <span>@connection.Username is looking for a chat!</span>
            <button @onclick="()=>RedirectToChat(connection.Username)">Start a chat</button>
        </div>
    }
</div>

@code {
    private HubConnection? authHub;
    private HubConnection? hubConnection;
    private List<UserConnections> userConnections { get; set; } = new();
    private string myConnectionId { get; set; } = string.Empty;
    private string? accessToken { get; set; }
    private HubInteractor? _hubInteractor;

    private async Task RedirectToChat(string username)
    {
        await RefreshTokensIfNeeded(accessToken!);

        Navigation.NavigateTo($"/user/{username}");
    }

    protected override async Task OnInitializedAsync()
    {
        accessToken = await jS.InvokeAsync<string?>("localStorage.getItem", "access-token");

        if (String.IsNullOrWhiteSpace(accessToken))
        {
            Navigation.NavigateTo("login");
            return;
        }

        authHub = new HubConnectionBuilder()
        .WithUrl(Navigation.ToAbsoluteUri("/authHub"))
        .Build();

        authHub.On<LogInResult>("OnTokensRefresh", async result =>
        {
            JWTPair? pair = result.JWTPair;
            if (pair == null || String.IsNullOrWhiteSpace(pair.AccessToken) || String.IsNullOrWhiteSpace(pair.RefreshToken.Token))
                Navigation.NavigateTo("/login");

            if(result.Result == LogInStatus.Success)
            {
                await jS.InvokeVoidAsync("localStorage.setItem", "access-token", pair!.AccessToken);
                await jS.InvokeVoidAsync("localStorage.setItem", "refresh-token", pair!.RefreshToken.Token);
            }
        });

        await authHub.StartAsync();

        await RefreshTokensIfNeeded(accessToken!);

        hubConnection = new HubConnectionBuilder()
        .WithUrl(Navigation.ToAbsoluteUri("/usersHub"))
        .Build();

        hubConnection.On<List<UserConnections>>("ReceiveOnlineUsers", updatedTrackedUserConnections =>
        {
            userConnections = updatedTrackedUserConnections;
            StateHasChanged();
        });

        hubConnection.On<string>("ReceiveConnectionId", conId =>
        {
            myConnectionId = conId;
            StateHasChanged();
        });

        await hubConnection.StartAsync();

        await hubConnection.SendAsync("SetUsername", await GetStoredAccessTokenAsync());

        _hubInteractor = new HubInteractor(Navigation);
        await _hubInteractor.ConnectToMessageDispatcherHubAsync(accessToken);
    }

    private async Task<string> GetStoredAccessTokenAsync()
    {
        return await jS.InvokeAsync<string>("localStorage.getItem", "access-token");
    }

    private async Task RefreshTokensIfNeeded(string accessToken)
    {
        if (TokenReader.HasAccessTokenExpired(accessToken))
        {
            string refreshToken = await jS.InvokeAsync<string>("localStorage.getItem", "refresh-token");
            await authHub.SendAsync("RefreshTokens", new RefreshToken { Token = refreshToken });
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (hubConnection != null)
        {
            await hubConnection.DisposeAsync();
        }
        if (authHub != null)
        {
            await authHub.DisposeAsync();
        }
        if (_hubInteractor != null)
        {
            await _hubInteractor.DisposeAsync();
        }
    }
}
