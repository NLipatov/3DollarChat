@page "/user/{topicName?}"
@using ClientServerCommon.Models;
@using ClientServerCommon.Models.Message;
@using Limp.Client.Cryptography.CryptoHandlers.Handlers;
@using Limp.Client.Cryptography.KeyStorage;
@using Limp.Client.HubInteraction.Handlers;
@using Limp.Client.HubInteraction;
@using Limp.Client.HubInteraction.Handlers.Helpers;
@using Limp.Client.Pages.PersonalChat.Logic.TokenRelatedOperations;
@using Limp.Client.Services.HubServices.CommonServices.SubscriptionService;
@using Limp.Client.Services.HubServices.MessageService;
@using Limp.Client.Services;
@using Microsoft.AspNetCore.SignalR.Client;
@using Limp.Client.Cryptography;
@using Limp.Client.HubInteraction.Handlers.MessageDecryption;
@using Limp.Client.HubInteraction.Handlers.MessageDispatcherHub.AESOfferHandling;
@using LimpShared.Encryption;
@using Limp.Client.Pages;
@using Limp.Client.Services.InboxService;
@using Limp.Client.Pages.PersonalChat.Logic.MessageBuilder;
@using Limp.Client.Pages.PersonalChat.UI.Childs.MessageCollectionDispaying;
@using Limp.Client.Pages.AuthenticationChecks
@inject NavigationManager _navigationManager
@inject IJSRuntime _jS
@inject ICryptographyService _cryptographyService
@inject IMessageDecryptor _messageDecryptor
@inject IMessageBox _messageBox
@inject IAESOfferHandler _aesOfferHandler
@inject IMessageService _messageService
@inject IHubServiceSubscriptionManager _hubServiceSubscriptionManager
@inject IMessageBuilder _messageBuilder
@implements IDisposable

<PageTitle>Chat with @topicName</PageTitle>

<AuthenticatedView>
    <AuthenticatedContent>
        <div class="page-container">
            <KeyBeingTransfered IsDisplayed="!AESKeyForConversationExists" />

            <div class="header">
                <span>@topicName</span>
            </div>

            <MessageList @ref=MessageListComponent
                         topicName=@topicName />

            <div class="message-input-box">
                <input @bind="messageInput" />
                <button @onclick="async () => await SendMessage()">Send</button>
            </div>
        </div>
    </AuthenticatedContent>
    <UnauthenticatedContent>
        <UnAuthorized/>
    </UnauthenticatedContent>
</AuthenticatedView>

@code {
    [Parameter]
    public string topicName { get; set; } = string.Empty;
    [Parameter]
    public string myUsername { get; set; } = string.Empty;
    private string messageInput = string.Empty;
    private List<UserConnection> userConnections { get; set; } = new();
    private bool AESKeyForConversationExists { get; set; } = false;
    private Guid ComponentId { get; set; }
    private MessageList? MessageListComponent { get; set; } = new();

    public void Dispose() => _hubServiceSubscriptionManager.RemoveComponentCallbacks(ComponentId);

    protected override async Task OnInitializedAsync()
    {
        //This id will be needed on dispose stage
        //On dispose stage we need to clear out all of the component event subscriptions
        ComponentId = Guid.NewGuid();

        myUsername = await TokenOperations.ResolveMyUsername(_jS);

        //If username was not read, ask user to relogin
        if (string.IsNullOrWhiteSpace(myUsername))
        {
            _navigationManager.NavigateTo("/login");
            return;
        }

        SubscribeToHubEvents();

        await GetAESKeyAsync();
    }

    private void SubscribeToHubEvents()
    {
        _hubServiceSubscriptionManager.AddCallback<string>(OnAESKeyReady, "OnPartnerAESKeyReady", ComponentId);
        _hubServiceSubscriptionManager.AddCallback<Guid>(MessageListComponent!.MarkAsReceived, "MessageWasReceivedByRecepient", ComponentId);
        _hubServiceSubscriptionManager.AddCallback<Message>(IncomingMessageReceived, "IncomingMessageReceived", ComponentId);
    }

    private async Task GetAESKeyAsync()
    {
        Key? key = GetAESKey();
        if(key != null)
        {
            return;
        }

        await _messageService.RequestForPartnerPublicKey(topicName);
    }

    public void OnAESKeyReady(string partnerName)
    {
        Key key = GetAESKey()!;
        StateHasChanged();
    }

    private Key? GetAESKey()
    {
        Key? aesKey = InMemoryKeyStorage.AESKeyStorage.FirstOrDefault(x => x.Key == topicName).Value;
        AESKeyForConversationExists = aesKey != null;

        return aesKey;
    }

    public void IncomingMessageReceived(Message message)
    {
        if (message.Sender == "You")
            return;

        if(message.Type == MessageType.UserMessage)
        {
            TryAddMessage(message);
        }
    }

    private void TryAddMessage(Message message)
    {
        if (MessageListComponent != null)
        {
            MessageListComponent.AddMessage(message);
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(messageInput))
            return;

        Message messageToSend = await _messageBuilder.BuildMessageToBeSend(messageInput, topicName, myUsername);

        await _messageService.SendMessage(messageToSend);

        messageToSend.Payload = messageInput;
        messageToSend.Sender = "You";
        TryAddMessage(messageToSend);
        await _messageBox.AddMessageAsync(messageToSend, isEncrypted: false);

        messageInput = string.Empty;
    }
}
