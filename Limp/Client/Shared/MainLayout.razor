@using Limp.Client.Cryptography;
@using Limp.Client.Cryptography.KeyStorage;
@using Limp.Client.HubInteraction.Handlers.Helpers;
@using Limp.Client.Services.HubConnectionProvider;
@using Limp.Client.Services.HubService.UsersService;
@using Limp.Client.Services.HubServices.CommonServices.SubscriptionService;
@using Limp.Client.Services.InboxService;
@using Limp.Client.Services.JWTReader;
@using Limp.Client.Services.NotificationService;
@using Limp.Client.Shared.ChildComponents
@using LimpShared.Encryption;
@using LimpShared.Models.WebPushNotification;
@inherits LayoutComponentBase
@inject ICryptographyService _cryptographyService
@inject IHubConnectionProvider _hubConnectionProvider
@inject IJSRuntime _jSRuntime
@inject IUsersService _usersService
@inject IWebPushService _webPushService
@inject IToastService _toastService
@inject IHubServiceSubscriptionManager _hubServiceSubscriptionManager
@inject IMessageBox _messageBox
@inject NavigationManager _navigationManager

@if (!isRSAGenerated)
{
    <div class="RSACalculatingWarning">
        <p>
            Calculating an RSA key pair...
        </p>
    </div>
}
else if(!isConnectedToHubs)
{
    <div class="RSACalculatingWarning">
        <p>
            Connecting to application server
        </p>
    </div>
}
else
{
    <div class="ApplicationContent">
        <SidebarMenu />
        <div style="width: 100%;">
            @Body
        </div>
    </div>
}

<BlazoredToasts 
    Position="Blazored.Toast.Configuration.ToastPosition.BottomRight"
    Timeout="2"/>

@code{
    private bool isRSAGenerated = false;
    private bool isConnectedToHubs = false;
    private Guid ComponentId { get; set; }
    public void Dispose() => _hubServiceSubscriptionManager.RemoveComponentCallbacks(ComponentId);

    protected override async Task OnInitializedAsync()
    {
        //This id will be needed on dispose stage
        //On dispose stage we need to clear out all of the component event subscriptions
        ComponentId = Guid.NewGuid();

        //Subscribing to server event of updating online users
        _hubServiceSubscriptionManager.AddCallback(ShowMessageToast, "MessageBoxUpdate", ComponentId);

        await _cryptographyService.GenerateRSAKeyPairAsync();
        KeysGeneratedHandler.SubscribeToRSAKeysGeneratedEvent(() =>
        {
            isRSAGenerated = true;
            StateHasChanged();
            _hubConnectionProvider.ConnectToHubs();
            isConnectedToHubs = true;
        });

        await _webPushService.RequestWebPushPermission();
    }

    private async void ShowMessageToast()
    {
        var unnotifiedAbout = _messageBox.Messages.Where(x => x.IsToastShown == false);
        foreach (var message in unnotifiedAbout)
        {
            if (!_navigationManager.Uri.Contains($"user/{message.Sender}") && message.Sender != await GetUsername())
            {
                _toastService.ShowInfo(message.Sender + ": " + message.PlainText);
            }
            _messageBox.OnToastWasShown(message.Id);
        }
    }

    private async Task<string> GetUsername()
    {
        string? accessToken = await JWTHelper.GetAccessTokenAsync(_jSRuntime);

        if (!TokenReader.IsTokenReadable(accessToken ?? string.Empty))
            throw new ArgumentException("Token was not readable");

        return TokenReader.GetUsernameFromAccessToken(accessToken);
    }
}