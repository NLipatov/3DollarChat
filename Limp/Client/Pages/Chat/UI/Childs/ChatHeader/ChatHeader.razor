@using EthachatShared.Encryption;
@using Ethachat.Client.Pages.Chat.UI.Childs.ChatHeader.Child;
@using Ethachat.Client.Pages.Chat.UI.Childs.ChatHeader.IndicatorTypes
@using Ethachat.Client.Services.HubServices.CommonServices.SubscriptionService
@using Ethachat.Client.Services.HubServices.HubServices.Implementations.MessageService
@using Ethachat.Client.Services.InboxService
@using EthachatShared.Models.Message
@inject IMessageBox _messageBox;
@inject IMessageService _messageService
@inject IHubServiceSubscriptionManager _hubServiceSubscriptionManager
@implements IDisposable

<div class="header">
    <div class="profile-picture @(IsOnline ? "online" : "")">
        <img src=@AvatarLink alt="Profile Picture">
    </div>
    <div class="contact-info">
        <h2 class="name">@PartnerName</h2>
        @if (IsTyping)
        {
            <p class="status">Typing...</p>
        }
        else if (IsSendingBinary)
        {
            <p class="status">Sending a file...</p>
        }
        else
        {
            <p class="status">@(IsOnline ? "Active now" : "Seen recently")</p>
        }
    </div>
    <div class="key-info">
        <button title="Clear conversation" @onclick="DeleteConversation" style="border: none;">
            <i class="bi bi-trash-fill key-icon"></i>
        </button>
        <button title="Renew AES Key" style="border: none;" @onclick=ShowModalAsync>
            <i class="bi bi-key-fill key-icon"></i>
        </button>
        @if (AESKey != null)
        {
            <div class="key-details">
                <p class="key-label">AES-secured</p>
                <p class="key-value">Key creation date: @AESKey.CreationDate.ToLocalTime().ToString("dd/MM HH:mm")</p>
            </div>
        }
    </div>
</div>

<AESKeyRenewalModal
    @ref=aesRenewalModal
    OnAESRenewal="OnAESRenewal"/>

@code {
    [Parameter] public string PartnerName { get; set; } = "Unnamed";
    [Parameter] public bool IsOnline { get; set; } = false;
    [Parameter] public string AvatarLink { get; set; } = "https://shorturl.at/gxAE7";
    [Parameter] public Key? AESKey { get; set; }
    [Parameter] public EventCallback OnAESRenewal { get; set; }
    private AESKeyRenewalModal? aesRenewalModal { get; set; }
    private Guid ComponentId { get; set; }
    private bool IsTyping { get; set; }
    private CancellationTokenSource typingCancellation = new();
    private bool IsSendingBinary { get; set; }
    private CancellationTokenSource fileDownloadingCancellation = new();
    private const int EventIndicatorCooldown = 600;

    public void Dispose() => _hubServiceSubscriptionManager.RemoveComponentCallbacks(ComponentId);


    protected override async Task OnInitializedAsync()
    {
        ComponentId = Guid.NewGuid();

        SubscribeToHubEvents();
    }

    private void SubscribeToHubEvents()
    {
        _hubServiceSubscriptionManager.AddCallback<string>(async partnerName =>
        {
            await ChangeHeaderIndicator(partnerName, IndicatorType.TYPING);
        }, "OnTyping", ComponentId);
        
        _hubServiceSubscriptionManager.AddCallback<string>(async partnerName =>
        {
            await ChangeHeaderIndicator(partnerName, IndicatorType.FILESENDING);
        }, "BinaryMessageChunkReceived", ComponentId);
    }

    private void SwitchIndicator(IndicatorType indicatorType, bool value)
    {
        if (indicatorType == IndicatorType.TYPING)
        {
            IsTyping = value;
            StateHasChanged();
            return;
        }

        if (indicatorType == IndicatorType.FILESENDING)
        {
            IsSendingBinary = value;
            StateHasChanged();
            return;
        }

        throw new ArgumentException($"Unsupported indicator type passed in: {nameof(indicatorType)}");
    }

    private async Task ChangeHeaderIndicator(string partnerName, IndicatorType indicatorType)
    {
        if (partnerName == PartnerName)
        {
            CancellationToken cancellationToken;
            //Cancel previous token so typing indicator will not be removed (user's still typing)
            if (indicatorType is IndicatorType.TYPING)
            {
                await typingCancellation.CancelAsync();
                typingCancellation = new();
                cancellationToken = typingCancellation.Token;
            }
            else
            {
                await fileDownloadingCancellation.CancelAsync();
                fileDownloadingCancellation = new();
                cancellationToken = fileDownloadingCancellation.Token;
            }

            //Show indicator
            SwitchIndicator(indicatorType, true);

            //Wait for some time and remove indicator
            try
            {
                await Task.Delay(EventIndicatorCooldown, cancellationToken);
            }
            catch (TaskCanceledException)
            {
                //Token's cancelled meaning that event is still happening
                return;
            }

            SwitchIndicator(indicatorType, false);
        }
    }

    private Guid GetFileId(Message message)
    {
        return message.Type switch
        {
            MessageType.Metadata => message.Metadata!.DataFileId,
            MessageType.DataPackage => message.Package!.FileDataid,
            _ => throw new ArgumentException("Unknown message type")
        };
    }

    private async Task ShowModalAsync()
    {
        if (aesRenewalModal != null)
            await aesRenewalModal.ShowModalAsync();
    }

    private void DeleteConversation()
    {
        _messageService.RequestPartnerToDeleteConvertation(PartnerName);
        _messageBox.Delete(PartnerName);
    }

}